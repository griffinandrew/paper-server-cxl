// Hybrid allocator using DRAM (jemalloc) up to a limit, then PMEM
use core::alloc::{GlobalAlloc, Layout};
use std::sync::{Once, atomic::{AtomicUsize, Ordering}};
use std::ptr;
use tikv_jemallocator::Jemalloc;
use std::ptr::null_mut;

mod allocator_bindings {
    include!("umf_allocator_bindings.rs"); // generated by bindgen
}

/// Hybrid allocator: first DRAM up to a limit, then PMEM
pub struct HybridGlobal;

static INIT: Once = Once::new();
static DRAM_ALLOCATED: AtomicUsize = AtomicUsize::new(0);
static mut DRAM_LIMIT: usize = 1024 * 1024 * 1024 * 1; // default 1 GiB

static ALL_MEM_ALLOCATED: AtomicUsize = AtomicUsize::new(0);

static PRINT_THRESHOLD: usize = 1000;
static mut LAST_PRINT_ALLOC: usize = 0;
static mut LAST_PRINT_DEALLOC: usize = 0;

const HDR_SIZE: usize = std::mem::size_of::<Header>();

//  per-allocation metadata
#[repr(C)]
#[derive(Debug)]
struct Header {
    offset: u32, // offset from raw ptr to user ptr
    size: u64,   // size of user allocation... dont really need this... 
    tag: u8,     // 0 = jemalloc, 1 = UMF, etc.
}


impl HybridGlobal {
    pub fn set_dram_limit(limit: usize) {
        unsafe { DRAM_LIMIT = limit; }
        unsafe { println!("dram limit set to {}", limit) }
    }

    /// Should this allocation go to DRAM or PMEM?
    pub fn should_use_dram(size: usize) -> bool {
        let current = DRAM_ALLOCATED.load(Ordering::Relaxed);
        unsafe { current + size <= DRAM_LIMIT }
    }
}
    

unsafe impl GlobalAlloc for HybridGlobal {
    /// Set the DRAM limit in bytes
    unsafe fn alloc(&self, layout: Layout) -> *mut u8 {
        let header_layout = Layout::new::<Header>();
        let (combined_layout, offset) = header_layout.extend(layout)
            .expect("Layout::extend failed");

        if should_use_dram(combined_layout.size()){
            let raw: *mut u8 = Jemalloc::alloc(combined_layout);
            if raw.is_null() {
                return ptr::null_mut();
            }

            // The header is at the start
            let hdr = raw as *mut Header;
            (*hdr).offset = offset as u32;
            (*hdr).size = layout.size() as u64;
            (*hdr).tag = 0;

            // The user pointer is offset bytes after the header
            let user_ptr = raw.add(offset);

            DRAM_ALLOCATED.fetch_add(combined_layout.size(), Ordering::SeqCst);
            ALL_MEM_ALLOCATED.fetch_add(combined_layout.size(), Ordering::SeqCst);

            unsafe {
                LAST_PRINT_ALLOC += 1;
                if LAST_PRINT_ALLOC >= PRINT_THRESHOLD {
                    LAST_PRINT_ALLOC = 0;
                    println!("Alloc: total allocated memory: {} bytes", ALL_MEM_ALLOCATED.load(Ordering::SeqCst));
                }
            }

            user_ptr
        } else {
            let raw: *mut u8 = allocator_bindings::umf_alloc(combined_layout.size()) as *mut u8;
            if raw.is_null() {
                return ptr::null_mut();
            }

            // The header is at the start
            let hdr = raw as *mut Header;
            (*hdr).offset = offset as u32;
            (*hdr).size = layout.size() as u64;
            (*hdr).tag = 1;

            // The user pointer is offset bytes after the header
            let user_ptr = raw.add(offset);

            ALL_MEM_ALLOCATED.fetch_add(combined_layout.size(), Ordering::SeqCst);

            unsafe {
                LAST_PRINT_ALLOC += 1;
                if LAST_PRINT_ALLOC >= PRINT_THRESHOLD {
                    LAST_PRINT_ALLOC = 0;
                    println!("Alloc: total allocated memory: {} bytes", ALL_MEM_ALLOCATED.load(Ordering::SeqCst));
                }
            }

            user_ptr
        }


    }

    unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {
        unsafe {
            if ptr.is_null() { return; }

            // Retrieve header from just before the user pointer
            let hdr_ptr = (ptr as *mut u8).sub(HDR_SIZE) as
            let header = ptr::read(hdr_ptr);
            let offset = header.offset as usize;

            if header.tag == 0 { //its in dram... just call jemalloc?
                //but i guess i need the total size??? is that why I stored it in the header?
                let combined_layout = 


                
                DRAM_ALLOCATED.fetch_sub(total_size, Ordering::SeqCst);
                ALL_MEM_ALLOCATED.fetch_sub(total_size, Ordering::SeqCst);
            } else {
                let size = layout.size();
                let align = layout.align(); 
                // total_size used when the backend needs the original allocation size
                let extra = if align > 0 { align - 1 } else { 0 };
                let total_size = size + HDR_SIZE + extra;

                // Reconstruct the raw pointer from header + offset
                let hdr_addr = hdr_ptr as usize;
                let raw_addr = hdr_addr - (header.offset as usize);
                let raw_ptr = raw_addr as *mut u8;

                allocator_bindings::umf_dealloc(raw_ptr as *mut std::ffi::c_void);
                ALL_MEM_ALLOCATED.fetch_sub(total_size, Ordering::SeqCst);
            }

            
        }
    }
}
